import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) throws Exception {
        // ask if the user wants to encrypt or decrypt a message
        Scanner sc = new Scanner(System.in);

        System.out.println("Would you like to encrypt or decrypt a message?");
        String answer = sc.nextLine();

        if (answer.equals("encrypt")) {
            System.out.println("Enter a message to encrypt:");
            String message = sc.nextLine();
            System.out.println("Enter a key:");
            int key = sc.nextInt();

            String encryptedMessage = encrypt(message, key);

            System.out.println("Your encrypted message is:");
            System.out.println(encryptedMessage);
        } else if (answer.equals("decrypt")) {
            System.out.println("Enter a message to decrypt:");
            String message = sc.nextLine();
            System.out.println("Enter a key:");
            String key = sc.nextLine();

            System.out.println("Your decrypted message is:");
            System.out.println(decrypt(message, key));
        } else {
            System.out.println("Please enter a valid answer.");
        }
    }

    public static String encrypt(String message, int key) throws Exception {
        // map each character to unique binary code
        ArrayList<String> binary = CipherEncryption.binaryMapper(message);
        System.out.println("Binary: " + binary);

        // shuffle binary code sequence randomly based on the key using a permutation algorithm
        ArrayList<String> shuffledBinary = CipherEncryption.binaryShuffler(binary, key);
        System.out.println("Shuffled binary: " + shuffledBinary);

        // XOR encrypt the shuffled binary code sequence using the key
        ArrayList<String> encryptedBinary = CipherEncryption.xorEncryption(shuffledBinary);
        System.out.println("Encrypted binary: " + encryptedBinary);

        // bitwise shift the encrypted binary code sequence by a random number of bits
        ArrayList<String> shiftedBinary = CipherEncryption.shiftBinary(encryptedBinary, key % 8);
        System.out.println("Shifted binary: " + shiftedBinary);

        // use substitution cipher to map each binary code to a character
        StringBuilder encryptedMessage = CipherEncryption.subCipher(shiftedBinary);
        System.out.println("Encrypted message: " + encryptedMessage);

        // substituted sequence is then reversed, so that the last symbol becomes the first, the second-last symbol becomes the second, and so on
        encryptedMessage.reverse();
        System.out.println("Encrypted message: " + encryptedMessage);

        // transposition cipher is applied to the reversed sequence, rearranging the symbols in a predetermined way
        StringBuilder transposedMessage = CipherEncryption.transpositionCipher(encryptedMessage, key);
        System.out.println("Transposed message: " + transposedMessage);

        // transposed sequence is then XOR encrypted again, but this time using a repeating key that is generated by repeating the original encryption key in a pattern
        StringBuilder finalMessage = CipherEncryption.keyXOREncryption(transposedMessage, key);
        System.out.println("Final message: " + finalMessage);

        // encrypted sequence is then reduced modulo a random prime number to produce a new sequence
        BigInteger prime = PrimeGenerator.generatePrimeWithKey(key);
        System.out.println("Your new decryption key is: " + prime.intValue() + " " + key);

        StringBuilder reducedMessage = CipherEncryption.moduloReduction(finalMessage, prime.intValue() % 395);
        System.out.println("Reduced message: " + reducedMessage);

        // new sequence is then converted to a different number base, such as base 64, using a custom conversion scheme
        StringBuilder base64Message = CipherEncryption.base64Conversion(reducedMessage);
        System.out.println("Base 64 message: " + base64Message);

        // sequence is then broken into blocks of a fixed length, and each block is substituted using a different substitution cipher
        StringBuilder blockMessage = CipherEncryption.blockConversion(base64Message, key);
        System.out.println("Block message: " + blockMessage);

        // substituted blocks are then encrypted using a keyless encryption algorithm, such as the one-time pad
        StringBuilder oneTimePadMessage = CipherEncryption.onePadEncryption(blockMessage);
        System.out.println("One time pad message: " + oneTimePadMessage);

        // sequence is encoded using a standard encoding scheme, such as UTF-8, to produce the encrypted message
        return oneTimePadMessage.toString();
    }

    public static String decrypt(String message, String totalKey) {
        int key = Integer.parseInt(totalKey.split(" ")[1]);
        int prime = Integer.parseInt(totalKey.split(" ")[0]);

        StringBuilder oneTimePadMessage = new StringBuilder(message);

        StringBuilder blockMessage = ReverseCipherEncryption.reverseOnePadEncryption(oneTimePadMessage);
        System.out.println("Block message: " + blockMessage);

        StringBuilder base64Message = ReverseCipherEncryption.reverseBlockConversion(blockMessage, key);
        System.out.println("Base 64 message: " + base64Message);

        StringBuilder reducedMessage = new StringBuilder(ReverseCipherEncryption.reverseBase64Conversion(String.valueOf(base64Message)));
        System.out.println("Reduced message: " + reducedMessage);

        StringBuilder finalMessage = ReverseCipherEncryption.reverseModuloReduction(reducedMessage, prime % 395);
        System.out.println("Final message: " + finalMessage);

        StringBuilder transposedMessage = new StringBuilder(ReverseCipherEncryption.reverseKeyXOREncryption(finalMessage, key).toString().trim());
        System.out.println("Transposed message: " + transposedMessage);

        StringBuilder encryptedMessage = new StringBuilder(ReverseCipherEncryption.reverseTranspositionCipher(transposedMessage, key).toString().trim());
        System.out.println("Encrypted message: " + encryptedMessage);

        encryptedMessage.reverse();
        System.out.println("Encrypted message: " + encryptedMessage);

        ArrayList<String> shiftedBinary = ReverseCipherEncryption.reverseSubCipher(encryptedMessage);
        System.out.println("Shifted binary: " + shiftedBinary);

        ArrayList<String> encryptedBinary = ReverseCipherEncryption.reverseShiftBinary(shiftedBinary, key % 8);
        System.out.println("Encrypted binary: " + encryptedBinary);

        ArrayList<String> shuffledBinary = ReverseCipherEncryption.reverseXorEncryption(encryptedBinary);
        System.out.println("Shuffled binary: " + shuffledBinary);

        ArrayList<String> binary = ReverseCipherEncryption.reverseBinaryShuffler(shuffledBinary, key);
        System.out.println("Binary: " + binary);

        System.out.println("Decrypted message: " + ReverseCipherEncryption.binaryToString(binary));

        return ReverseCipherEncryption.binaryToString(binary);
    }
}
/*
Binary: [1110100, 1100101, 1110011, 1110100]
Shuffled binary: [1100101, 1110011, 1110100, 1110100]
Encrypted binary: [0011010, 0001100, 0001011, 0001011]
Shifted binary: [0110100, 0011000, 0010110, 0010110]
Encrypted message: 4
Encrypted message: 4
Transposed message: 4
Final message: 5
Your new decryption key is: 2 1
Reduced message: 7
Base 64 message: GRkbNw==
Block message: RkbNw==G
One time pad message: SjcOv<<F
Your encrypted message is:
SjcOv<<F
 */